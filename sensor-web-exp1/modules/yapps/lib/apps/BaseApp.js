// Generated by LiveScript 1.4.0
(function(){
  var broadway, optimist, extendify, bunyan, bunyanDebugStream, bunyanRotatingFile, path, colors, applyCmdConfigs, InitFunctions, BaseApp, exports;
  if (process.env['TIME_REQUIRE'] === "true") {
    require('time-require');
  }
  broadway = require('broadway');
  optimist = require('optimist');
  extendify = require('extendify');
  bunyan = require('bunyan');
  bunyanDebugStream = require('bunyan-debug-stream');
  bunyanRotatingFile = require('bunyan-rotating-file');
  path = require('path');
  colors = require('colors');
  applyCmdConfigs = function(settings, type){
    var i$, len$, s, tokens, prop, value, names, lastName, config, j$, len1$, n, results$ = [];
    if (!settings) {
      return;
    }
    settings = settings instanceof Array
      ? settings
      : [settings];
    for (i$ = 0, len$ = settings.length; i$ < len$; ++i$) {
      s = settings[i$];
      tokens = s.split("=");
      prop = tokens[0];
      value = tokens[1];
      if ('"' === value.charAt(0) && '"' === value.charAt(value.length - 1)) {
        value = value.substr(1, value.length - 2);
      } else {
        if ("'" === value.charAt(0) && "'" === value.charAt(value.length - 1)) {
          value = value.substr(1, value.length - 2);
        }
      }
      names = prop.split(".");
      lastName = names.pop();
      config = global.config;
      for (j$ = 0, len1$ = names.length; j$ < len1$; ++j$) {
        n = names[j$];
        config = config[n];
      }
      switch (type) {
      case "string":
        config[lastName] = value;
        break;
      case "integer":
        config[lastName] = parseInt(value);
        break;
      case "boolean":
        config[lastName] = "true" === value.toLowerCase();
        break;
      case "str_array":
        config[lastName] = value.split(',');
        break;
      default:
        config[lastName] = value;
      }
      results$.push(INFO("applying " + prop + " = " + config[lastName]));
    }
    return results$;
  };
  InitFunctions = [
    {
      name: 'string-helpers',
      func: function(){
        if (typeof String.prototype.startsWith !== 'function') {
          String.prototype.startsWith = function(str){
            return str === this.substring(0, str.length);
          };
        }
        if (typeof String.prototype.endsWith !== 'function') {
          return String.prototype.endsWith = function(str){
            return str === this.substring(this.length - str.length, this.length);
          };
        }
      }
    }, {
      name: 'load-config',
      func: function(){
        var resource, opt;
        resource = module.resource;
        opt = optimist.usage('Usage: $0').alias('c', 'config').describe('c', 'the configuration set, might be default, bbb0, ...')['default']('c', 'default').alias('b', 'config_bool').describe('b', 'overwrite a configuration with boolean value, e.g. -b "system.influxServer.secure=false"').alias('s', 'config_string').describe('s', 'overwrite a configuration with boolean value, e.g. -b "system.influxServer.user=smith"').alias('i', 'config_int').describe('i', 'overwrite a configuration with int value, e.g. -b "behavior.notify.influxPeriod=smith"').alias('a', 'config_str_array').describe('a', 'overwrite a configuration with array of strings with delimiter character `COMMA`, e.g. -b "system.influxServer.clusters=aa.test.net,bb.test.net,cc.test.net"').alias('v', 'verbose').describe('v', 'verbose message output (level is changed to `debug`)')['default']('v', false).alias('q', 'quiet').describe('q', 'disable logging outputs to local file, but still outputs to stderr')['default']('q', false).boolean(['h', 'v']);
        global.argv = opt.argv;
        if (global.argv.h) {
          opt.showHelp();
          process.exit(0);
        }
        global.config = resource.loadConfig(global.argv.config);
        if (global.config == null) {
          return process.exit(1);
        }
        applyCmdConfigs(global.argv.s, "string");
        applyCmdConfigs(global.argv.i, "integer");
        applyCmdConfigs(global.argv.b, "boolean");
        return applyCmdConfigs(global.argv.a, "str_array");
      }
    }
  ];
  BaseApp = (function(){
    BaseApp.displayName = 'BaseApp';
    var prototype = BaseApp.prototype, constructor = BaseApp;
    function BaseApp(opts, helpers){
      this.opts = opts;
      this.helpers = helpers;
      DBG("BaseApp constructor");
      this.type = 'base';
      this.name = this.opts.name;
      this.resource = module.resource = helpers.resource;
      this.asyncExecutor = helpers.asyncExecutor;
      this.plugin_instances = [];
    }
    prototype.addPlugin = function(p){
      return this.opts.plugins.push(p);
    };
    prototype.initLogger = function(){
      var plugins, resource, app_name, prefixers, stringifiers, level, logging_dir, logging_opts, logger, app_logger, global_logger;
      plugins = this.opts.plugins;
      resource = this.resource;
      app_name = this.name;
      prefixers = {
        module: function(m){
          if (m.plugin != null && m.plugin) {
            return "plugin::" + m.name;
          }
          if (m.debug != null && m.debug) {
            return "debug::" + m.name;
          }
          return m.name;
        }
      };
      stringifiers = {
        config: function(c){
          return JSON.stringify(c, null, 4);
        }
      };
      /*
      for let p, i in plugins
        config = global.config[p]
        if config? and config[\logger]?
          log_config = config.logger
          if log_config[\prefixers]?
            for let name, func of log_config.prefixers
              if prefixers[name]?
                INFO "plugin[#{p}] loads a duplicate logging prefixer <#{name}>"
              else
                prefixers[name] = func
      
          if log_config[\stringifiers]?
            for let name, func of log_config.stringifiers
              if stringifiers[name]?
                INFO "plugin[#{p}] loads a duplicate logging prefixer <#{name}>"
              else
                stringifiers[name] = func
      */
      if (global.argv.v != null && global.argv.v) {
        DBG("verbose (-v) is enabled");
      }
      level = global.argv.v ? 'debug' : 'info';
      logging_dir = resource.resolveWorkPath('logs', '');
      logging_opts = {
        name: app_name,
        serializers: bunyanDebugStream.serializers,
        streams: [
          {
            level: level,
            type: 'raw',
            stream: bunyanDebugStream({
              out: process.stderr,
              showProcess: false,
              colors: {
                debug: 'gray',
                info: 'white'
              },
              prefixers: prefixers,
              stringifiers: stringifiers
            })
          }, {
            level: 'debug',
            type: 'rotating-file',
            path: logging_dir + "" + path.sep + "/app.log",
            period: '1d',
            count: 7
          }
        ]
      };
      if (global.argv.q) {
        logging_opts.streams.pop();
      }
      this.extendify = extendify();
      if (global.config.logger != null) {
        logging_opts = this.extendify(logging_opts, global.config.logger);
      }
      global.yapp_logger = logger = bunyan.createLogger(logging_opts);
      app_logger = this.logger = logger.child({
        module: {
          name: 'BaseApp'
        }
      });
      app_logger.debug("logger initiated");
      global_logger = logger.child({
        module: {
          name: 'GLOBAL'
        }
      });
      global.DBG = function(){
        return global_logger.debug.apply(global_logger, arguments);
      };
      global.INFO = function(){
        return global_logger.info.apply(global_logger, arguments);
      };
      global.WARN = function(){
        return global_logger.warn.apply(global_logger, arguments);
      };
      global.ERR = function(){
        return global_logger.error.apply(global_logger, arguments);
      };
      global.FATAL = function(){
        return global_logger.fatal.apply(global_logger, arguments);
      };
      return module.DBGT = function(){
        return app_logger.debug.apply(app_logger, arguments);
      };
    };
    prototype.init = function(done){
      var self, asyncExecutor, resource, opts, plugins, i$, ref$, len$, app, tasks, logger, config, context, ae;
      self = this;
      asyncExecutor = self.asyncExecutor, resource = self.resource, opts = self.opts;
      plugins = opts.plugins;
      for (i$ = 0, len$ = (ref$ = InitFunctions).length; i$ < len$; ++i$) {
        (fn$.call(this, i$, ref$[i$]));
      }
      this.initLogger();
      app = this.app = new broadway.App;
      app.parent = self;
      tasks = [
        {
          name: 'dummy',
          func: function(ae, ctx, dbg, done){
            return done();
          }
        }, {
          name: 'load-plugins',
          func: function(ae, ctx, dbg, done){
            var config, app, plugins, self, i$, len$;
            config = ctx.config, app = ctx.app, plugins = ctx.plugins, self = ctx.self;
            for (i$ = 0, len$ = plugins.length; i$ < len$; ++i$) {
              (fn$.call(this, i$, plugins[i$]));
            }
            return done();
            function fn$(i, p){
              var name, logger, helpers, c, error;
              try {
                name = p.NAME;
                logger = self.logger.child({
                  module: {
                    plugin: true,
                    name: name
                  }
                });
                helpers = {
                  logger: logger
                };
                helpers = self.extendify(helpers, self.helpers);
                c = {};
                if (config[name] != null) {
                  c = self.extendify(c, config[name]);
                }
                c = self.extendify(c, {
                  helpers: helpers
                });
                app.use(p, c);
                self.plugin_instances.push(p);
              } catch (e$) {
                error = e$;
                return done(error);
              }
            }
          }
        }, {
          name: 'init-plugins',
          func: function(ae, ctx, dbg, done){
            var app;
            app = ctx.app;
            return app.init(function(err){
              return done(err);
            });
          }
        }, {
          name: 'startup-plugins',
          func: function(ae, ctx, dbg, done){
            dbg("enter");
            return done();
          }
        }
      ];
      logger = self.logger;
      config = global.config;
      context = {
        config: config,
        resource: resource,
        app: app,
        plugins: plugins,
        self: self
      };
      ae = new asyncExecutor({
        type: 'app',
        logger: module.DBGT,
        context: context
      });
      return ae.series(tasks, function(executor, ctx, err, results){
        if (process.env['TIME_REQUIRE'] === "true") {
          return process.exit(0);
        }
        if (err == null) {
          return done();
        }
        self.logger.error(err, "initialization failure");
        return done(err);
      });
      function fn$(i, init_func){
        DBG("booting: " + init_func.name + " ...");
        init_func.func();
      }
    };
    prototype.get = function(name){
      return this.app[name];
    };
    prototype.on = function(){
      var onFunc;
      onFunc = this.app.on;
      return onFunc.apply(this.app, arguments);
    };
    return BaseApp;
  }());
  module.exports = exports = BaseApp;
}).call(this);
