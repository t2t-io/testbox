// Generated by LiveScript 1.4.0
/*
 * Livescript middleware
 * copied from Stylus middleware
 */
(function(){
  /**
   * Module dependencies.
   */
  /*
  require! {
    'uglify-js': {minify}
    LiveScript: livescript
  
    fs
    url
    path: {join, sep, dirname}
    mkdirp
  }
  */
  var minify, livescript, fs, url, mkdirp, path, join, sep, dirname, defaults;
  minify = require('uglify-js').minify;
  livescript = require('livescript');
  fs = require('fs');
  url = require('url');
  mkdirp = require('mkdirp');
  path = require('path');
  join = path.join, sep = path.sep, dirname = path.dirname;
  defaults = {
    compress: false
  };
  module.exports = function(options){
    var dest, src;
    options == null && (options = {});
    if (typeof options === 'string') {
      options = {
        src: options
      };
    }
    options = import$(defaults, options);
    dest = options.dest, src = options.src;
    if (src == null) {
      throw new Error('livescript.middleware() requires "src" directory');
    }
    dest || (dest = src);
    options.compile || (options.compile = function(str, path){
      return livescript.compile(str, {
        bare: options.bare
      });
    });
    return function(req, res, next){
      var path, overlap, jsPath, lsPath, error;
      if (!arrayContains(['GET', 'HEAD'], req.method)) {
        return next();
      }
      path = url.parse(req.url).pathname;
      if (!/\.js$/.test(path)) {
        return next();
      }
      if (arrayContains(['string', 'function'], typeof dest)) {
        overlap = compare(typeof dest === 'function' ? dest(path) : dest, path);
        path = path.slice(overlap.length);
      }
      jsPath = typeof dest === 'function'
        ? dest(path)
        : join(dest, path);
      lsPath = typeof src === 'function'
        ? src(path)
        : join(src, path.replace('.js', '.ls'));
      error = function(err){
        return next(err.code === 'ENOENT' ? null : err);
      };
      if (options.force) {
        return compile();
      }
      fs.stat(lsPath, function(err, lsStats){
        if (err) {
          return error(err);
        }
        return fs.stat(jsPath, function(err, jsStats){
          if (err) {
            if (err.code === 'ENOENT') {
              return compile();
            } else {
              return next(err);
            }
          } else {
            if (lsStats.mtime > jsStats.mtime) {
              return compile();
            } else {
              return next();
            }
          }
        });
      });
      function compile(){
        return fs.readFile(lsPath, 'utf8', function(err, str){
          var js;
          if (err) {
            return error(err);
          }
          try {
            js = options.compile(str, {});
            if (options.compress) {
              js = minify(js, {
                fromString: true
              }).code;
            }
            return mkdirp(dirname(jsPath), 448, function(err){
              if (err) {
                return error(err);
              }
              return fs.writeFile(jsPath, js, 'utf8', next);
            });
          } catch (e$) {
            err = e$;
            return error(err);
          }
        });
      }
      return compile;
    };
  };
  function arrayContains(haystack, needle){
    return -1 !== haystack.indexOf(needle);
  }
  /**
   * get the overlapping path from the end of path A, and the begining of path B.
   *
   * @param {String} pathA
   * @param {String} pathB
   * @return {String}
   * @api private
   */
  function compare(pathA, pathB){
    var overlap;
    pathA = pathA.split(sep);
    pathB = pathB.split(sep);
    overlap = [];
    while (pathA[pathA.length - 1] === pathB[0]) {
      overlap.push(pathA.pop());
      pathB.shift();
    }
    return overlap.join(sep);
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
}).call(this);
